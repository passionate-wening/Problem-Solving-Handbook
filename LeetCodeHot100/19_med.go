package LeetCodeHot100

/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	p1 := head
	for i := 0; i < n; i++ {
		p1 = p1.Next
	}
	if p1 == nil { //删除头节点
		return head.Next
	} else { //删除p2的下一个节点
		p2 := head
		for p1.Next != nil {
			p1 = p1.Next
			p2 = p2.Next
		}
		p2.Next = p2.Next.Next
		return head
	}
}

/*
【题解】
双指针，删除倒数第几个节点，就让其中一个指针p1先走几步。
已知n <= sz，所以最边缘情况就是走到空。
如果当前p1为空，说明删除头节点，直接返回头结点的下一个；
其他情况都说明删除非头节点，让p2只向头，跟着p1走，p1指到尾节点时，删除p2的下一个节点。
已知n >= 1，所以p1一定离开头节点了，p1、p2不重合。
其他情况时不用担心p2的下一个节点情况，因为我们可以保证p1非空，且p2在p1后面。
ps：拿到题立刻写框框报错，写完分析再写代码一把通关；警示，遇事先分析，欲速则不达。
*/

/*
官方题解给出了先统计个数，再删除的做法，看似两个方法性能差不多，但网友的解释特别好：
“首先不管是删除第几个，两次遍历或者双指针，指针移动次数都是链表长度*2-n，其次，双指针中两个指针离的越近，后指针就越有可能利用前指针的缓存，缓存大小是另一个因素，如果无限大则第二次访问必命中，如果只有一个指针长度那么第二次必不命中。”
“极端情况下双指针更优，比如内存很小，链表很长，单指针可能触发更多的缓存不命中，导致更多的低速读。”
*/

/*
官方题解给出的栈的方法性能不好，但掌握栈的使用也很重要，有时间可以写写。
*/
